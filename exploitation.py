from asyncio import constants
from os import environ
import numpy as np
import importlib
import torch
import matplotlib.pyplot as plt


ENVIRONMENT_NAME = 'pendulum_gym'
ENVIRONMENT_NAME = 'pendulum_gym'

ENVIRONMENT_PATH = f'environments.{ENVIRONMENT_NAME}'
MODEL_PATH = f'models.{ENVIRONMENT_NAME}'
ORACLE_PATH = f'oracles.{ENVIRONMENT_NAME}'

environment = importlib.import_module(ENVIRONMENT_PATH)
# models = importlib.import_module(MODEL_PATH)


plot = False
# plot = True

d, m = environment.d, environment.m
T = 101
# dt = 80e-3
# environment.dt = dt
dt = environment.dt

gamma = environment.gamma
sigma = environment.sigma

x0 = environment.x0



def task_cost(U, dynamics, gradient_step=None):
    value = 0.0
    x_t = torch.zeros(d)
    for t in range(T):
        u_t = U[t, :]
        # u_t = torch.clip(u_t, -gamma, gamma)
        # print(f'xt {x_t}')
        value += environment.step_cost(x_t, u_t)
        # print(f'gradient_step {gradient_step}, t={t}, value {value}')
        # print(f'dt = {dt}')
        x_t_ = x_t + dt*dynamics(x_t, u_t)
        x_t = x_t_
        if plot and gradient_step%400 ==0 and t%1 == 0:
            environment.plot_pendulum(x_t.detach().numpy())
            text = f'step {gradient_step}, t={t}, x={x_t}'
            plt.title(text)
            plt.pause(0.1)
            plt.close()
    return value

def plan(model, n_gradient):
    U = torch.randn(T, m, requires_grad=True)
    optimizer = torch.optim.Adam([U], 0.02)
    loss_values = np.zeros(n_gradient)
    for gradient_step in range(n_gradient):
        V = torch.clip(U, -gamma, gamma)
        loss = task_cost(V, model, gradient_step)
        loss_values[gradient_step] = loss
        # print(f'loss = {loss}')

        optimizer.zero_grad() ; loss.backward() ; optimizer.step()
    return U, loss_values

def exploitation(model, dynamics, n_gradient=500):
    U, loss_values = plan(model, n_gradient)
    temp = environment.dt
    environment.dt = 80e-3
    cost = task_cost(U, dynamics)
    environment.dt = temp
    return cost, loss_values
# model = environment.d_dynamics
# U, loss_values = plan(model)
# final_cost = task_cost(U, environment.dynamics)
# print(f'final cost: {final_cost}')

# plt.plot(loss_values) ; plt.show()
